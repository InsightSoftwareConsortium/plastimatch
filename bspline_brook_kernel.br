/* -----------------------------------------------------------------------
   See COPYRIGHT.TXT and LICENSE.TXT for copyright and license information
   ----------------------------------------------------------------------- */
#include <stdio.h>
#include <math.h>

/* AUTHOR: Naga Kandasamy, 08/15/2008, revison 1 */

/* Kernel computes the displacement value in the X, Y, or Z directions */
kernel void compute_dxyz_kernel(float c_lut[][],
					     float q_lut[][],
					     float coeff[][],
					     float3 volume_dim, // X, Y, Z dimensions of the volume
					     float3 vox_per_rgn, // Number of voxels per region
					     float3 rdims, // The X, Y, Z dimensions of the control knot grid
					     float volume_texture_size, 
					     float c_lut_texture_size,
					     float q_lut_texture_size,
					     float coeff_texture_size,
					     float xyz, // xyz = 0 for x, 1 for y and 2 for z
					     float sixty_four,	    // Pass 64 as a parameter to work around fxc bug
					     out float4 result<>)
{
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	float my_index = (volume_texture_size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	float voxel_number;
	float curr_index;
	float3 vox_coordinate; // X, Y, Z coordinates for this voxel
	float3 p, q; // Region index 
	float pidx, qidx;
	float k;
	float cidx = 0;
	float x_index_of_q_lut, y_index_of_q_lut;
	float x_index_of_c_lut, y_index_of_c_lut;
	float x_index_of_coeff, y_index_of_coeff;
	float my_out;
	
	if (my_index > volume_dim.x*volume_dim.y*volume_dim.x) // Voxel lies outside the volume
	{ 
		result = 0.0;
	}
	else
	{
		for (voxel_number = 0.0; voxel_number < 4.0; voxel_number = voxel_number + 1.0) // Iterate through the four voxels
		{ 
			/* Get the X, Y, Z position of the voxel */
			curr_index = my_index + voxel_number; // Get correct index of the voxel
			vox_coordinate.z = floor(curr_index/(volume_dim.x*volume_dim.y)); // Calculate the z index
			vox_coordinate.y = floor((curr_index - vox_coordinate.z*(volume_dim.x*volume_dim.y))/volume_dim.x); // Calculate the y index
			vox_coordinate.x = curr_index - vox_coordinate.z*volume_dim.x*volume_dim.y - vox_coordinate.y*volume_dim.x; // Calculate the x index
		
			/* Get the tile location of the voxel */
			p.x = floor(vox_coordinate.x/vox_per_rgn.x);
			p.y = floor(vox_coordinate.y/vox_per_rgn.y);
			p.z = floor(vox_coordinate.z/vox_per_rgn.z);
			
			/* Get the offset of the voxel within the tile */
			q.x = vox_coordinate.x - p.x * vox_per_rgn.x;
			q.y = vox_coordinate.y - p.y * vox_per_rgn.y;
			q.z = vox_coordinate.z - p.z * vox_per_rgn.z;
			
			/* Use the tile location of the voxel to compute the index into the c_lut */
			pidx = ((p.z * rdims.y + p.y) * rdims.x) + p.x;
			
			/* Use the offset if the voxel to compute the index into the multiplier LUT or q_lut */
			qidx = ((q.z * vox_per_rgn.y + q.y) * vox_per_rgn.x) + q.x;
			
			my_out = 0.0;
			for (k = 0.0; k < sixty_four; k = k + 1.0)
			{
				/* Index into the c_lut texture */
				y_index_of_c_lut = floor((pidx*64 + k)/c_lut_texture_size);
				x_index_of_c_lut = (pidx*64 + k) - y_index_of_c_lut*c_lut_texture_size;
				
				/* Index into the q_lut texture */
				y_index_of_q_lut = floor((qidx*64 + k)/q_lut_texture_size);
				x_index_of_q_lut = (qidx*64 + k) - y_index_of_q_lut*q_lut_texture_size;
				
				/* Index into the texture of control-knot coefficients */
				cidx =  c_lut[y_index_of_c_lut][x_index_of_c_lut]* 3 + xyz; 
				y_index_of_coeff = floor(cidx/coeff_texture_size);
				x_index_of_coeff = cidx - y_index_of_coeff*coeff_texture_size;
				
				/* Compute influence of the voxel in the x, y, or z direction */
				my_out += q_lut[y_index_of_q_lut][x_index_of_q_lut] * coeff[y_index_of_coeff][x_index_of_coeff]; 
			} // k loop 	
		
			if(voxel_number == 0.0) result.x = my_out;
			if(voxel_number == 1.0) result.y = my_out;
			if(voxel_number == 2.0) result.z = my_out;
			if(voxel_number == 3.0) result.w = my_out;
		} //Voxel loop
	}
}

/* This kernel computes the intensity difference between the voxels in the moving and static images */
kernel void compute_diff_kernel(float4 fixed_image[][], 
						  float4 moving_image[][], 
						  float4 dx[][],
						  float4 dy[][],
						  float4 dz[][],
						  float3 volume_dim, // X, Y, Z dimensions of the volume
						  float3 img_origin, // X, Y, Z coordinates for the image origin 
						  float3 pix_spacing, // Dimensions of a single voxel
						  float3 img_offset, // Offset corresponding to the region of interest
						  float volume_texture_size,
						  float eight,
						  float four,
						  out float4 result<>)
{
	
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	float my_index = (volume_texture_size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	float i;
	float voxel_number;
	float curr_index;
	float3 vox_coordinate;
	float3 distance_from_image_origin;
	float3 displacement_in_mm; 
	float3 displacement_in_vox;
	
	float3 displacement_in_vox_round; 
	float3 displacement_in_vox_floor;
	
	float fx1, fx2;
	float fy1, fy2;
	float fz1, fz2;

	float m_lin_tex;
	float2 m_tex;
	float m_ele;
	float m_intensity = 0.0;
	
	float mvf = 0.0;
	float n_mvf;
	float m_val = 0.0;
	float t_val;
	float f_intensity;
	
	if (my_index > volume_dim.x*volume_dim.y*volume_dim.x) // Voxel lies outside the volume
	{ 
		result = 0.0;
	}
	else
	{
		for (voxel_number = 0.0; voxel_number < four; voxel_number = voxel_number + 1.0) // Iterate through the four voxels
		{ 
			/* Get the X, Y, Z position of the voxel */
			curr_index = my_index + voxel_number; // Get correct index of the voxel
			vox_coordinate.z = floor(curr_index/(volume_dim.x*volume_dim.y)); // Calculate the z index
			vox_coordinate.y = floor((curr_index - vox_coordinate.z*(volume_dim.x*volume_dim.y))/volume_dim.x); // Calculate the y index
			vox_coordinate.x = curr_index - vox_coordinate.z*volume_dim.x*volume_dim.y - vox_coordinate.y*volume_dim.x; // Calculate the x index
			
			distance_from_image_origin.x = img_origin.x + pix_spacing.x*vox_coordinate.x; // Distance of voxel in mm from the origin along the X axis
			distance_from_image_origin.y = img_origin.y + pix_spacing.y*vox_coordinate.y; // Distance of voxel in mm from the origin along the Y axis
			distance_from_image_origin.z = img_origin.z + pix_spacing.z*vox_coordinate.z; // Distance of voxel in mm from the origin along the Z axis
			
			if(voxel_number == 0.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].x; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].x; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].x; // Displacement of voxel in mm in the Z direction
				f_intensity = fixed_image[temp.y][temp.x].x; // Intensity value of the voxel in the fixed image
			}
			else if(voxel_number == 1.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].y; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].y; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].y; // Displacement of voxel in mm in the Z direction
				f_intensity = fixed_image[temp.y][temp.x].y; // Intensity value of the voxel in the fixed image
			}
			else if(voxel_number == 2.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].z; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].z; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].z; // Displacement of voxel in mm in the Z direction
				f_intensity = fixed_image[temp.y][temp.x].z; // Intensity value of the voxel in the fixed image
			}
			else if(voxel_number == 3.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].w; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].w; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].w; // Displacement of voxel in mm in the Z direction
				f_intensity = fixed_image[temp.y][temp.x].w; 
			}
			
			displacement_in_vox.x = (displacement_in_mm.x - img_offset.x)/pix_spacing.x; // Convert the displacement value in terms of voxels
			displacement_in_vox.y = (displacement_in_mm.y - img_offset.y)/pix_spacing.y;
			displacement_in_vox.z = (displacement_in_mm.z - img_offset.z)/pix_spacing.z;
			
			/* Check if the displaced voxel lies outside the region of interest */
			if ((displacement_in_vox.x < -0.5) || (displacement_in_vox.x > (volume_dim.x - 0.5)) || 
				(displacement_in_vox.y < -0.5) || (displacement_in_vox.y > (volume_dim.y - 0.5)) || 
				(displacement_in_vox.z < -0.5) || (displacement_in_vox.z > (volume_dim.z - 0.5))){
					if(voxel_number == 0.0) result.x = 0;
					if(voxel_number == 1.0) result.y = 0;
					if(voxel_number == 2.0) result.z = 0;
					if(voxel_number == 3.0) result.w = 0;
				}
			else{
				/* Clamp and interpolate along the X axis */
				displacement_in_vox_floor.x = floor(displacement_in_vox.x); // Get the "floor" voxel
				displacement_in_vox_round.x = round(displacement_in_vox.x); // Get the "round" voxel
				fx2 = displacement_in_vox.x - displacement_in_vox_floor.x;
				if(displacement_in_vox_floor.x < 0){
					displacement_in_vox_floor.x = 0;
					displacement_in_vox_round.x = 0;
					fx2 = 0.0;
				}
				else if(displacement_in_vox_floor.x >= (volume_dim.x - 1)){
					displacement_in_vox_floor.x = volume_dim.x - 2;
					displacement_in_vox_round.x = volume_dim.x - 1;
					fx2 = 1.0;
				}
				fx1 = 1.0 - fx2;
				
				/* Clamp and interpolate along the Y axis */
				displacement_in_vox_floor.y = floor(displacement_in_vox.y);
				displacement_in_vox_round.y = round(displacement_in_vox.y);
				fy2 = displacement_in_vox.y - displacement_in_vox_floor.y;
				if(displacement_in_vox_floor.y < 0){
					displacement_in_vox_floor.y = 0;
					displacement_in_vox_round.y = 0;
					fy2 = 0.0;
				}
				else if(displacement_in_vox_floor.y >= (volume_dim.y - 1)){
					displacement_in_vox_floor.y = volume_dim.y - 2;
					displacement_in_vox_round.y = volume_dim.y - 1;
					fy2 = 1.0;
				}
				fy1 = 1.0 - fy2;
				
				/* Clamp and intepolate along the Z axis */
				displacement_in_vox_floor.z = floor(displacement_in_vox.z);
				displacement_in_vox_round.z = round(displacement_in_vox.z);
				fz2 = displacement_in_vox.z - displacement_in_vox_floor.z;
				if(displacement_in_vox_floor.z < 0){
					displacement_in_vox_floor.z = 0;
					displacement_in_vox_round.z = 0;
					fz2 = 0.0;
				}
				else if(displacement_in_vox_floor.z >= (volume_dim.z - 1)){
					displacement_in_vox_floor.z = volume_dim.z - 2;
					displacement_in_vox_round.z = volume_dim.z - 1;
					fz2 = 1.0;
				}
				fz1 = 1.0 - fz2;
				
				/* Obtain the displacement of the voxel in the ID array */
				mvf = (displacement_in_vox_floor.z*volume_dim.y + displacement_in_vox_floor.y)*volume_dim.x + displacement_in_vox_floor.x;
				m_val = 0.0;
				for(i = 0.0; i < eight; i = i + 1.0){
					if(i == 0.0) {
						t_val = fx1*fy1*fz1;
						n_mvf = mvf + 0.0;
					}
					else if(i == 1.0) {
						t_val = fx2*fy1*fz1;
						n_mvf = mvf + 1.0;
					}
					else if(i == 2.0) {
						t_val = fx1*fy2*fz1;
						n_mvf = mvf + volume_dim.x;
					}
					else if(i == 3.0) {
						t_val = fx2*fy2*fz1;
						n_mvf = mvf + volume_dim.x + 1;
					}
					else if(i == 4.0) {
						t_val = fx1*fy1*fz2;
						n_mvf = mvf + volume_dim.y*volume_dim.x;
					}
					else if(i == 5.0) {
						t_val = fx2*fy1*fz2;
						n_mvf = mvf + volume_dim.y*volume_dim.x + 1;
					}
					else if(i == 6.0) {
						t_val = fx1*fy2*fz2;
						n_mvf = mvf + volume_dim.y*volume_dim.x + volume_dim.x;
					}
					else if(i == 7.0) {
						t_val = fx2*fy2*fz2;
						n_mvf = mvf + volume_dim.y*volume_dim.x + volume_dim.x + 1;	
					}
					
					/* Map the n_mvf index into the corresponding 2D texture of the moving image */
					m_lin_tex = floor(n_mvf/4); // ID index of the float4 texture
					m_tex.y = floor(m_lin_tex/volume_texture_size); // Y coordinate of the texture
					m_tex.x = m_lin_tex - m_tex.y*volume_texture_size; // X coordinate of the texture
					m_ele = n_mvf - 4*m_lin_tex; // Index into the float4 element
					
					if(m_ele == 0.0){
						m_intensity = moving_image[m_tex.y][m_tex.x].x;
					}
					else if(m_ele == 1.0){
						m_intensity = moving_image[m_tex.y][m_tex.x].y;
					}
					
					else if(m_ele == 2.0){
						m_intensity = moving_image[m_tex.y][m_tex.x].z;
					}
					else if(m_ele == 3.0){
						m_intensity = moving_image[m_tex.y][m_tex.x].w;
					}
					
					m_val = m_val + t_val*m_intensity;
				} // End for loop
				
				if(voxel_number == 0.0) result.x = f_intensity - m_val;
				if(voxel_number == 1.0) result.y = f_intensity - m_val;
				if(voxel_number == 2.0) result.z = f_intensity - m_val;
				if(voxel_number == 3.0) result.w = f_intensity - m_val;
			} // End else
		} // End for loop
	} // End Else 
}


/* Kernel computes the number of valid voxels */
kernel void compute_valid_voxels_kernel(float4 dx[][],
										float4 dy[][],
										float4 dz[][],
										float3 volume_dim, // X, Y, Z dimensions of the volume
										float3 img_origin, // X, Y, Z coordinates for the image origin 
										float3 pix_spacing, // Dimensions of a single voxel
										float3 img_offset, // Offset corresponding to the region of interest
										float volume_texture_size,
										out float4 result<>)
{
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	float my_index = (volume_texture_size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	float voxel_number;
	float curr_index;
	
	float3 vox_coordinate;
	float3 distance_from_image_origin, displacement_in_mm, displacement_in_vox;
	
	
	if (my_index > volume_dim.x*volume_dim.y*volume_dim.x) // Voxel lies outside the volume
	{ 
		result.x = 0.0; // These voxels dont count
		result.y = 0.0;
		result.z = 0.0;
		result.w = 0.0;
	}
	else
	{
		for (voxel_number = 0.0; voxel_number < 4; voxel_number = voxel_number + 1.0) // Iterate through the four voxels
		{ 
			/* Get the X, Y, Z position of the voxel */
			curr_index = my_index + voxel_number; // Get correct index of the voxel
			vox_coordinate.z = floor(curr_index/(volume_dim.x*volume_dim.y)); // Calculate the z index
			vox_coordinate.y = floor((curr_index - vox_coordinate.z*(volume_dim.x*volume_dim.y))/volume_dim.x); // Calculate the y index
			vox_coordinate.x = curr_index - vox_coordinate.z*volume_dim.x*volume_dim.y - vox_coordinate.y*volume_dim.x; // Calculate the x index
			
			distance_from_image_origin.x = img_origin.x + pix_spacing.x*vox_coordinate.x; // Distance of voxel in mm from the origin along the X axis
			distance_from_image_origin.y = img_origin.y + pix_spacing.y*vox_coordinate.y; // Distance of voxel in mm from the origin along the Y axis
			distance_from_image_origin.z = img_origin.z + pix_spacing.z*vox_coordinate.z; // Distance of voxel in mm from the origin along the Z axis
			
			if(voxel_number == 0.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].x; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].x; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].x; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 1.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].y; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].y; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].y; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 2.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].z; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].z; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].z; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 3.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].w; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].w; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].w; // Displacement of voxel in mm in the Z direction
			}
			
			displacement_in_vox.x = (displacement_in_mm.x - img_offset.x)/pix_spacing.x; // Convert the displacement value in terms of voxels
			displacement_in_vox.y = (displacement_in_mm.y - img_offset.y)/pix_spacing.y;
			displacement_in_vox.z = (displacement_in_mm.z - img_offset.z)/pix_spacing.z;
			
			/* Check if the displaced voxel lies outside the region of interest */
			if ((displacement_in_vox.x < -0.5) || (displacement_in_vox.x > (volume_dim.x - 0.5)) || 
				(displacement_in_vox.y < -0.5) || (displacement_in_vox.y > (volume_dim.y - 0.5)) || 
				(displacement_in_vox.z < -0.5) || (displacement_in_vox.z > (volume_dim.z - 0.5))){
					if(voxel_number == 0.0) result.x = 0; // These voxels don't count
					if(voxel_number == 1.0) result.y = 0;
					if(voxel_number == 2.0) result.z = 0;
					if(voxel_number == 3.0) result.w = 0;
				}
				else{
					if(voxel_number == 0.0) result.x = 1; // These voxels count
					if(voxel_number == 1.0) result.y = 1;
					if(voxel_number == 2.0) result.z = 1;
					if(voxel_number == 3.0) result.w = 1;
				}
		} // For loop
	} // Else
}				

/* Kernel computes the number of valid voxels */
kernel void compute_valid_voxels_kernel_revised(float4 dx[][],
										float4 dy[][],
										float4 dz[][],
										float3 volume_dim, // X, Y, Z dimensions of the volume
										float3 img_origin, // X, Y, Z coordinates for the image origin 
										float3 pix_spacing, // Dimensions of a single voxel
										float3 img_offset, // Offset corresponding to the region of interest
										float volume_texture_size,
										out float result<>)
{
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	float my_index = (volume_texture_size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	float voxel_number;
	float curr_index;
	
	float3 vox_coordinate;
	float3 distance_from_image_origin, displacement_in_mm, displacement_in_vox;
	
	
	if (my_index > volume_dim.x*volume_dim.y*volume_dim.x) // Voxel lies outside the volume
	{ 
		result = 0.0; // These voxels dont count
	}
	else
	{
		result = 0.0;
		for (voxel_number = 0.0; voxel_number < 4; voxel_number = voxel_number + 1.0) // Iterate through the four voxels
		{ 
			/* Get the X, Y, Z position of the voxel */
			curr_index = my_index + voxel_number; // Get correct index of the voxel
			vox_coordinate.z = floor(curr_index/(volume_dim.x*volume_dim.y)); // Calculate the z index
			vox_coordinate.y = floor((curr_index - vox_coordinate.z*(volume_dim.x*volume_dim.y))/volume_dim.x); // Calculate the y index
			vox_coordinate.x = curr_index - vox_coordinate.z*volume_dim.x*volume_dim.y - vox_coordinate.y*volume_dim.x; // Calculate the x index
			
			distance_from_image_origin.x = img_origin.x + pix_spacing.x*vox_coordinate.x; // Distance of voxel in mm from the origin along the X axis
			distance_from_image_origin.y = img_origin.y + pix_spacing.y*vox_coordinate.y; // Distance of voxel in mm from the origin along the Y axis
			distance_from_image_origin.z = img_origin.z + pix_spacing.z*vox_coordinate.z; // Distance of voxel in mm from the origin along the Z axis
			
			if(voxel_number == 0.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].x; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].x; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].x; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 1.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].y; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].y; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].y; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 2.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].z; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].z; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].z; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 3.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].w; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].w; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].w; // Displacement of voxel in mm in the Z direction
			}
			
			displacement_in_vox.x = (displacement_in_mm.x - img_offset.x)/pix_spacing.x; // Convert the displacement value in terms of voxels
			displacement_in_vox.y = (displacement_in_mm.y - img_offset.y)/pix_spacing.y;
			displacement_in_vox.z = (displacement_in_mm.z - img_offset.z)/pix_spacing.z;
			
			/* Check if the displaced voxel lies outside the region of interest */
			if ((displacement_in_vox.x >= -0.5) && (displacement_in_vox.x <= (volume_dim.x - 0.5)) && 
				(displacement_in_vox.y >= -0.5) && (displacement_in_vox.y <= (volume_dim.y - 0.5)) && 
				(displacement_in_vox.z >= -0.5) && (displacement_in_vox.z <= (volume_dim.z - 0.5))){
					result = result + 1;
				}
		} // For loop
	} // Else
}				



/* Kernel computes the dc_dv values used to update the control-knot coefficients */
kernel void compute_dc_dv_kernel(float4 moving_grad[][],
						  float4 diff[][],
						  float4 mvr[][],
						  float3 volume_dim, // X, Y, Z dimensions of the volume
						  float3 img_origin, // X, Y, Z coordinates for the image origin 
						  float3 pix_spacing, // Dimensions of a single voxel
						  float3 img_offset, // Offset corresponding to the region of interest
						  float volume_texture_size,
						  out float4 result<>)
{
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	float my_index = (volume_texture_size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	float voxel_number;
	float m_mvr;
	float m_diff, m_grad;
	float m_lin_tex;
	float2 m_tex;
	float m_ele;
	
	if (my_index > volume_dim.x*volume_dim.y*volume_dim.x) // Voxel lies outside the volume
	{ 
		result = 0.0;
	}
	else
	{
		for (voxel_number = 0.0; voxel_number < 4.0; voxel_number = voxel_number + 1.0) // Iterate through the four voxels
		{ 
			if(voxel_number == 0.0) {
				m_mvr = mvr[temp.y][temp.x].x;
				m_diff = diff[temp.y][temp.x].x;
			}
			else if(voxel_number == 1.0){
				m_mvr = mvr[temp.y][temp.x].y;
				m_diff = diff[temp.y][temp.x].y;
			}
			else if(voxel_number == 2.0){
				m_mvr = mvr[temp.y][temp.x].z;
				m_diff = diff[temp.y][temp.x].z;
			}
			else if(voxel_number == 3.0) {
				m_mvr = mvr[temp.y][temp.x].w;
				m_diff = diff[temp.y][temp.x].w;
			}		
			
			/* Map the mvr index into the corresponding 2D texture of gradient values. */
			m_lin_tex = floor(m_mvr/4); // ID index of the float4 texture
			m_tex.y = floor(m_lin_tex/volume_texture_size); // Y coordinate of the texture
			m_tex.x = m_lin_tex - m_tex.y*volume_texture_size; // X coordinate of the texture
			m_ele = m_mvr - 4*m_lin_tex; // Index into the float4 element
				
			/* Compute the spatial gradient using nearest neighbors */
			if(m_ele == 0.0){
				m_grad = moving_grad[m_tex.y][m_tex.x].x;
			}
			else if(m_ele == 1.0){
				m_grad = moving_grad[m_tex.y][m_tex.x].y;
			}
			else if(m_ele == 2.0){
				m_grad = moving_grad[m_tex.y][m_tex.x].z;
			}
			else if(m_ele == 3.0){
				m_grad = moving_grad[m_tex.y][m_tex.x].w;
			} 
				
			if(voxel_number == 0.0) result.x = m_diff*m_grad;
			if(voxel_number == 1.0) result.y = m_diff*m_grad;
			if(voxel_number == 2.0) result.z = m_diff*m_grad;
			if(voxel_number == 3.0) result.w = m_diff*m_grad;
		} // End for
	} // End else
}

/* Kernel computes the mvr values */
kernel void compute_mvr_kernel(float4 dx[][],
						  float4 dy[][],
						  float4 dz[][],
						  float3 volume_dim, // X, Y, Z dimensions of the volume
						  float3 img_origin, // X, Y, Z coordinates for the image origin 
						  float3 pix_spacing, // Dimensions of a single voxel
						  float3 img_offset, // Offset corresponding to the region of interest
						  float volume_texture_size,
						  out float4 result<>)
{
	
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	float my_index = (volume_texture_size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	float i;
	float voxel_number;
	float curr_index;
	float3 vox_coordinate;
	float3 distance_from_image_origin;
	float3 displacement_in_mm; 
	float3 displacement_in_vox;
	
	float3 displacement_in_vox_round; 
	float3 displacement_in_vox_floor;
	
	float mvr;
	
	if (my_index > volume_dim.x*volume_dim.y*volume_dim.x) // Voxel lies outside the volume
	{ 
		result = 0.0;
	}
	else
	{
		for (voxel_number = 0.0; voxel_number < 4.0; voxel_number = voxel_number + 1.0) // Iterate through the four voxels
		{ 
			/* Get the X, Y, Z position of the voxel */
			curr_index = my_index + voxel_number; // Get correct index of the voxel
			vox_coordinate.z = floor(curr_index/(volume_dim.x*volume_dim.y)); // Calculate the z index
			vox_coordinate.y = floor((curr_index - vox_coordinate.z*(volume_dim.x*volume_dim.y))/volume_dim.x); // Calculate the y index
			vox_coordinate.x = curr_index - vox_coordinate.z*volume_dim.x*volume_dim.y - vox_coordinate.y*volume_dim.x; // Calculate the x index
			
			distance_from_image_origin.x = img_origin.x + pix_spacing.x*vox_coordinate.x; // Distance of voxel in mm from the origin along the X axis
			distance_from_image_origin.y = img_origin.y + pix_spacing.y*vox_coordinate.y; // Distance of voxel in mm from the origin along the Y axis
			distance_from_image_origin.z = img_origin.z + pix_spacing.z*vox_coordinate.z; // Distance of voxel in mm from the origin along the Z axis
			
			if(voxel_number == 0.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].x; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].x; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].x; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 1.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].y; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].y; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].y; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 2.0){
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].z; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].z; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].z; // Displacement of voxel in mm in the Z direction
			}
			else if(voxel_number == 3.0) {
				displacement_in_mm.x = distance_from_image_origin.x + dx[temp.y][temp.x].w; // Displacement of voxel in mm in the X direction
				displacement_in_mm.y = distance_from_image_origin.y + dy[temp.y][temp.x].w; // Displacement of voxel in mm in the Y direction
				displacement_in_mm.z = distance_from_image_origin.z + dz[temp.y][temp.x].w; // Displacement of voxel in mm in the Z direction
			}
			
			displacement_in_vox.x = (displacement_in_mm.x - img_offset.x)/pix_spacing.x; // Convert the displacement value in terms of voxels
			displacement_in_vox.y = (displacement_in_mm.y - img_offset.y)/pix_spacing.y;
			displacement_in_vox.z = (displacement_in_mm.z - img_offset.z)/pix_spacing.z;
			
			/* Check if the displaced voxel lies outside the region of interest */
			if ((displacement_in_vox.x < -0.5) || (displacement_in_vox.x > (volume_dim.x - 0.5)) || 
				(displacement_in_vox.y < -0.5) || (displacement_in_vox.y > (volume_dim.y - 0.5)) || 
				(displacement_in_vox.z < -0.5) || (displacement_in_vox.z > (volume_dim.z - 0.5))){
					if(voxel_number == 0.0) result.x = 0;
					if(voxel_number == 1.0) result.y = 0;
					if(voxel_number == 2.0) result.z = 0;
					if(voxel_number == 3.0) result.w = 0;
				}
			else{
				/* Clamp and interpolate along the X axis */
				displacement_in_vox_floor.x = floor(displacement_in_vox.x); // Get the "floor" voxel
				displacement_in_vox_round.x = round(displacement_in_vox.x); // Get the "round" voxel
				if(displacement_in_vox_floor.x < 0){
					displacement_in_vox_floor.x = 0;
					displacement_in_vox_round.x = 0;
				}
				else if(displacement_in_vox_floor.x >= (volume_dim.x - 1)){
					displacement_in_vox_floor.x = volume_dim.x - 2;
					displacement_in_vox_round.x = volume_dim.x - 1;
				}
				
				/* Clamp and interpolate along the Y axis */
				displacement_in_vox_floor.y = floor(displacement_in_vox.y);
				displacement_in_vox_round.y = round(displacement_in_vox.y);
				if(displacement_in_vox_floor.y < 0){
					displacement_in_vox_floor.y = 0;
					displacement_in_vox_round.y = 0;
				}
				else if(displacement_in_vox_floor.y >= (volume_dim.y - 1)){
					displacement_in_vox_floor.y = volume_dim.y - 2;
					displacement_in_vox_round.y = volume_dim.y - 1;
				}
				
				/* Clamp and intepolate along the Z axis */
				displacement_in_vox_floor.z = floor(displacement_in_vox.z);
				displacement_in_vox_round.z = round(displacement_in_vox.z);
				if(displacement_in_vox_floor.z < 0){
					displacement_in_vox_floor.z = 0;
					displacement_in_vox_round.z = 0;
				}
				else if(displacement_in_vox_floor.z >= (volume_dim.z - 1)){
					displacement_in_vox_floor.z = volume_dim.z - 2;
					displacement_in_vox_round.z = volume_dim.z - 1;
				}
				
				/* Obtain the displacement of the voxel in the ID array */
				mvr = (displacement_in_vox_round.z*volume_dim.y + displacement_in_vox_round.y)*volume_dim.x + displacement_in_vox_round.x;
				
				if(voxel_number == 0.0) result.x = mvr;
				if(voxel_number == 1.0) result.y = mvr;
				if(voxel_number == 2.0) result.z = mvr;
				if(voxel_number == 3.0) result.w = mvr;
			} // End else
		} // End for loop
	} // End Else 
}		

/* This kernel squares the diff values */
kernel void compute_diff_squared_kernel(float4 diff<>, out float4 result<>)
{
	result.x = diff.x*diff.x;
	result.y = diff.y*diff.y;
	result.z = diff.z*diff.z;
	result.w = diff.w*diff.w;
}	

/* This kernel reduces the diff_squared values into a single float4 value */
reduce void compute_score_kernel(float4 diff_squared<>, reduce float4 result){
	result.x = result.x + diff_squared.x;
	result.y = result.y + diff_squared.y;
	result.z = result.z + diff_squared.z;
	result.w = result.w + diff_squared.w;
}  		  

kernel void accumulate_values_into_float_struct(float4 input_stream[][], out float4 result<>)
{
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	
	result.x = input_stream[temp.y][temp.x].x + 
		     input_stream[temp.y][temp.x].y + 
		     input_stream[temp.y][temp.x].z + 
		     input_stream[temp.y][temp.x].w;
	result.y = 0;
	result.z = 0;
	result.w = 0;
}

/* This kernel counts the number of valid voxels */
reduce void compute_sum_kernel(float input_stream<>, reduce float result){
	result = result + input_stream;
}

/* Test kernel */
kernel void test_kernel(float4 image<>, out float4 result<>)
{
	result = image + 1;
}

/* Kernel to initialize a stream with zeros */
kernel void init_stream(out float4 result<>)
{
	result = 0.0;
}

/* Initialize kernel values to one */
kernel void init_stream_to_one(out float4 result<>)
{
	result = 2;
}


/* Kernel reduces the elements of a 2D stream in the Y direction by summing them */
kernel void reduce_stream_in_y_direction(float4 input_stream[][], 
										 float stream_dimension,
										 float inner_loop_bound,
										 out float result<>)
{
	float2 temp = indexof(result); // Get (X, Y) index of our stream element in texture memory
	
	float outer_loop_bound;
	float left_over;
	float sum;
	float m; 
	float i, j;
	
	outer_loop_bound = floor(stream_dimension/inner_loop_bound);
	left_over = stream_dimension - outer_loop_bound*inner_loop_bound;

	m = 0;
	sum = 0;
	// Sum the elements along the Y dimension of the texture
	for(i = 0.0; i < outer_loop_bound; i = i + 1.0)
	{
		for(j = 0.0; j < inner_loop_bound; j = j + 1.0)
		{
			sum = sum + 
				  input_stream[temp.y + m][temp.x].x + 
				  input_stream[temp.y + m][temp.x].y + 
				  input_stream[temp.y + m][temp.x].z + 
				  input_stream[temp.y + m][temp.x].w;
			m = m + 1.0;
		}
	}
	
	// Sum up any left over elements
	for(i = 0.0; i < left_over; i = i + 1.0)
	{
		sum = sum + 
			input_stream[temp.y + m][temp.x].x + 
			input_stream[temp.y + m][temp.x].y + 
			input_stream[temp.y + m][temp.x].z + 
			input_stream[temp.y + m][temp.x].w;
		m = m + 1.0;
	}
	result = sum;
}