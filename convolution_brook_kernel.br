/* -----------------------------------------------------------------------
   See COPYRIGHT.TXT and LICENSE.TXT for copyright and license information
   ----------------------------------------------------------------------- */
#include <stdio.h>
#include <math.h>


// Kernel smooths the vector field in the x direction. It uses a gaussian filter with 3 elements
kernel void k_average_x(float4 vec_st[][], 
			float3 dim, 
			float size, 
			out float4 result<>)
{
    float2 temp = indexof(result); // Get index of the element being operated upon by the kernel in texture memory
    float my_index = (size*temp.y + temp.x)*4.0; //  Index of the element in a 1D stream
	
    if(my_index > dim.x*dim.y*dim.z){
	result = 0.0;
    }
    else{
	// Calculate coordinates of the voxel in the 3D volume
	float z_index = floor(my_index/(dim.x*dim.y)); // Calculate the z index of the voxel
	float y_index = floor((my_index - z_index*(dim.x*dim.y))/dim.x); // Calculate the y index of the voxel
	float x_index = my_index - z_index*dim.x*dim.y - y_index*dim.x; // Calculate the x index of the voxel
	
	float4 current = vec_st[temp.y][temp.x]; // Index of current element in 2D texture
	
	float right_index = (my_index + 4)/4; // Index of right neighbor in the 1D stream
	float y_right = floor(right_index/size); // Get corresponding x and y location in the texture memory
	float x_right = right_index - y_right*size;
	float4 right; // Right neighbor
	
	float left_index = (my_index - 4)/4; // Index of left neighbor in the 1D stream
	float y_left = floor(left_index/size); // Get corresponding x and y location in the texture memory
	float x_left = left_index - y_left*size;
	float4 left; // Left neighbor
	
	float3 ker = float3(0.2740686238, 0.4518627524, 0.2740686238); // 3 element gaussian kernel
	
	if(x_index == 0){ // No left neighbor, only right neighbor
	    right = vec_st[y_right][x_right]; // Right neighbor           
	    //result.x = (ker.x + ker.y)*current.x + ker.z*current.y; // Replicate left-most element
	    result.x = (ker.y)*current.x + ker.z*current.y; // Replicate left-most element
	    result.y = ker.x*current.x + ker.y*current.y + ker.z*current.z;        
	    result.z = ker.x*current.y + ker.y*current.z + ker.z*current.w;	
	    result.w = ker.x*current.z + ker.y*current.w + ker.z*right.x; // Convolve with right neighbor
	}
	else if(x_index == dim.x-4){ // No right neighbor, only left neighbor
	    left = vec_st[y_left][x_left]; // Left neighbor
	    result.x = ker.x*left.w + ker.y*current.x + ker.z*current.y; // Convolve with left neighbor
	    result.y = ker.x*current.x + ker.y*current.y + ker.z*current.z;
	    result.z = ker.x*current.y + ker.y*current.z + ker.z*current.w;
	    // result.w = ker.x*current.z + (ker.y + ker.z)*current.w;	
	    result.w = ker.x*current.z + (ker.y)*current.w;	
	}
	else{ // Current voxel has left and right neighbors
	    right = vec_st[y_right][x_right]; // Right neighbor 
	    left = vec_st[y_left][x_left]; // Left neighbor
		
	    result.x = ker.x*left.w + ker.y*current.x + ker.z*current.y; // Convolve with left neighbor
	    result.y = ker.x*current.x + ker.y*current.y + ker.z*current.z;
	    result.z = ker.x*current.y + ker.y*current.z + ker.z*current.w;
	    result.w = ker.x*current.z + ker.y*current.w + ker.z*right.x; // Convolve with right neighbor
	} 
    }
}

#if defined (commentout)
// Kernel smooths the vector field in the x direction. It uses a gaussian filter with 5 elements
kernel void k_average_x_five_element(float4 vec_st[][], 
									 float3 dim, 
									 float size,
									 float ker[][], // The 5 element kernel
									 out float4 result<>)
{
	float2 temp = indexof(result); // Get index of the element being operated upon by the kernel in texture memory
	
	float my_index = (size*temp.y + temp.x)*4.0; //  Index of the element in a 1D stream
	
	// Calculate coordinates of the voxel in the 3D volume
	float z_index = floor(my_index/(dim.x*dim.y)); // Calculate the z index of the voxel
	float y_index = floor((my_index - z_index*(dim.x*dim.y))/dim.x); // Calculate the y index of the voxel
	float x_index = my_index - z_index*dim.x*dim.y - y_index*dim.x; // Calculate the x index of the voxel
	
	float4 current = vec_st[temp.y][temp.x]; // Index of current element in 2D texture
	
	float right_index = (my_index + 4)/4; // Index of left neighbor in the 1D stream
	float y_right = floor(right_index/size); // Get corresponding x and y location in the texture memory
	float x_right = right_index - y_right*size;
	float4 right; // Right neighbor
	
	float left_index = (my_index - 4)/4; // Index of neighbor below our voxel in the 1D stream
	float y_left = floor(left_index/size); // Get corresponding x and y location in the texture memory
	float x_left = left_index - y_left*size;
	float4 left; // Left neighbor
	
	if(x_index == 0){ // No left neighbor, only right neighbor
		right = vec_st[y_right][x_right]; // Right neighbor 
		result.x = (ker[0][0] + ker[0][1] + ker[0][2])*current.x + ker[0][3]*current.y + ker[0][4]*current.z;
		result.y = (ker[0][0] + ker[0][1])*current.x + ker[0][2]*current.y + ker[0][3]*current.z + ker[0][4]*current.w;        
		result.z = ker[0][0]*current.x + ker[0][1]*current.y + ker[0][2]*current.z + ker[0][3]*current.w + ker[0][4]*right.x;     
		result.w = ker[0][0]*current.y + ker[0][1]*current.z + ker[0][2]*current.w + ker[0][3]*right.x + ker[0][4]*right.y;
	}
	else if(x_index == dim.x-4){
		left = vec_st[y_left][x_left]; // Left neighbor
		result.x = ker[0][0]*left.z + ker[0][1]* left.w + ker[0][2]*current.x + ker[0][3]*current.y + ker[0][4]*current.z;
		result.y = ker[0][0]*left.w + ker[0][1]* current.x + ker[0][2]*current.y + ker[0][3]*current.z + ker[0][4]*current.w;
		result.z = ker[0][0]*current.x + ker[0][1]* current.y + ker[0][2]*current.z + (ker[0][3] + ker[0][4])*current.w;
		result.w = ker[0][0]*current.y + ker[0][1]* current.z + ker[0][2]*current.w + (ker[0][3] + ker[0][4])*current.w;	
	}
	else{
		right = vec_st[y_right][x_right]; // Right neighbor 
		left = vec_st[y_left][x_left]; // Left neighbor
		result.x = ker[0][0]*left.z + ker[0][1]*left.w + ker[0][2]*current.x + ker[0][3]*current.y + ker[0][4]*current.z;
		result.y = ker[0][0]*left.w + ker[0][1]*current.x + ker[0][2]*current.y + ker[0][3]*current.z + ker[0][4]*current.w;
		result.z = ker[0][0]*current.x + ker[0][1]*current.y + ker[0][2]*current.z + ker[0][3]*current.w + ker[0][4]*right.x;
		result.w = ker[0][0]*current.y + ker[0][1]*current.z + ker[0][2]*current.w + ker[0][3]*right.x + ker[0][4]*right.y;
	}
}
#endif

// Kernel smooths the vector field in the y direction; uses three elements
kernel void k_average_y(float4 vec_st[][], 
			float3 dim, 
			float size, 
			out float4 result<>)
{
    float2 temp = indexof(result); // Get X, Y index of our stream element in texture memory
    float my_index = (size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
    if(my_index > dim.x*dim.y*dim.z){
	result = 0.0;
    }
    else{
	// Convert the 1D index into the corresponding x, y, and z position of voxel in the volume
	float z_index = floor(my_index/(dim.x*dim.y)); // Calculate the z index of the voxel
	float y_index = floor((my_index - z_index*(dim.x*dim.y))/dim.x); // Calculate the y index of the voxel
	float x_index = my_index - z_index*dim.x*dim.y - y_index*dim.x; // Calculate the x index of the voxel
	
	float4 current = vec_st[temp.y][temp.x]; // Index of our voxel in 2D texture
	float4 up; // Above neighbor
	float4 down; // Below neighbor
	
	float up_index = (my_index + dim.x)/4; // Index of neighbor above our voxel in the 1D stream
	float y_up = floor(up_index/size); // Get corresponding x and y location in the texture memory
	float x_up = up_index - y_up*size;
	
	float down_index = (my_index - dim.x)/4; // Index of neighbor below our voxel in the 1D stream
	float y_down = floor(down_index/size); // Get corresponding x and y location in the texture memory
	float x_down = down_index - y_down*size;
	
	float3 ker = float3(0.2740686238, 0.4518627524, 0.2740686238); // 3 element gaussian kernel
	
	if (y_index == 0){ // Our voxel has no neighbor below it		
	    up = vec_st[y_up][x_up]; // Get the voxel above it
	    //result.x = (ker.x + ker.y)*current.x + ker.z*up.x; // Convolve with neighbor above us
	    //result.y = (ker.x + ker.y)*current.y + ker.z*up.y; 
	    //result.z = (ker.x + ker.y)*current.z + ker.z*up.z; 
	    //result.w = (ker.x + ker.y)*current.w + ker.z*up.w; 	 
	    result.x = (ker.y)*current.x + ker.z*up.x; // Convolve with neighbor above us
	    result.y = (ker.y)*current.y + ker.z*up.y; 
	    result.z = (ker.y)*current.z + ker.z*up.z; 
	    result.w = (ker.y)*current.w + ker.z*up.w; 	 
	}
	else if (y_index == dim.y-1){ // Our voxel has no neighbor above it
	    down = vec_st[y_down][x_down]; // Get the voxel below it
	    //result.x = ker.x*down.x + (ker.y + ker.z)*current.x; // Convolve with neighbor below us
	    //result.y = ker.x*down.y + (ker.y + ker.z)*current.y;
	    //result.z = ker.x*down.z + (ker.y + ker.z)*current.z; 
	    //result.w = ker.x*down.w + (ker.y + ker.z)*current.w; 	
	    result.x = ker.x*down.x + (ker.y)*current.x; // Convolve with neighbor below us
	    result.y = ker.x*down.y + (ker.y)*current.y;
	    result.z = ker.x*down.z + (ker.y)*current.z; 
	    result.w = ker.x*down.w + (ker.y)*current.w; 	
	}
	else{ // Our voxel has neighbors above and below it
	    up = vec_st[y_up][x_up]; // Get the voxel above it
	    down = vec_st[y_down][x_down]; // Get the voxel below it
	    result.x = ker.x*down.x + ker.y*current.x + ker.z*up.x; // Convolve with neighbor above and below us
	    result.y = ker.x*down.y + ker.y*current.y + ker.z*up.y;
	    result.z = ker.x*down.z + ker.y*current.z + ker.z*up.z; 
	    result.w = ker.x*down.w + ker.y*current.w + ker.z*up.w; 
	}
    }
}

#if defined (commentout)
kernel void k_average_y_five_element(float4 vec_st[][], 
									 float3 dim, 
									 float size, 
									 float ker[][],
									out float4 result<>)
{
	float2 temp = indexof(result); // Get X, Y index of our stream element in texture memory
	float my_index = (size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
	// Convert the 1D index into the corresponding x, y, and z position of voxel in the volume
	float z_index = floor(my_index/(dim.x*dim.y)); // Calculate the z index of the voxel
	float y_index = floor((my_index - z_index*(dim.x*dim.y))/dim.x); // Calculate the y index of the voxel
	float x_index = my_index - z_index*dim.x*dim.y - y_index*dim.x; // Calculate the x index of the voxel
	
	float4 current = vec_st[temp.y][temp.x]; // Index of our voxel in 2D texture
	float4 up1;
	float4 up2; // Two above neighbors
	float4 down1;
	float4 down2; // Two below neighbors
	
	/* Calculate the positions of the two voxels above us */
	float up_index_1 = (my_index + dim.x)/4;
	float y_up_1 = floor(up_index_1/size); // Get corresponding x and y location in the texture memory
	float x_up_1 = up_index_1 - y_up_1*size;
	
	float up_index_2 = (my_index + 2*dim.x)/4; 
	float y_up_2 = floor(up_index_2/size); // Get corresponding x and y location in the texture memory
	float x_up_2 = up_index_2 - y_up_2*size;
	
	/* Calculate the positions of the two voxels below us */
	float down_index_1 = (my_index - dim.x)/4; // Index of neighbor below our voxel in the 1D stream
	float y_down_1 = floor(down_index_1/size); // Get corresponding x and y location in the texture memory
	float x_down_1 = down_index_1 - y_down_1*size;
	
	float down_index_2 = (my_index - 2*dim.x)/4; // Index of neighbor below our voxel in the 1D stream
	float y_down_2 = floor(down_index_2/size); // Get corresponding x and y location in the texture memory
	float x_down_2 = down_index_2 - y_down_2*size;
	
	if(y_index == 0){ // Our voxel has no neighbors below it
		up1 = vec_st[y_up_1][x_up_1];
		up2 = vec_st[y_up_2][x_up_2];
		result.x = (ker[0][0] + ker[0][1] + ker[0][2])*current.x + ker[0][3]*up1.x + ker[0][4]*up2.x;
		result.y = (ker[0][0] + ker[0][1] + ker[0][2])*current.y + ker[0][3]*up1.y + ker[0][4]*up2.y;
		result.x = (ker[0][0] + ker[0][1] + ker[0][2])*current.z + ker[0][3]*up1.z + ker[0][4]*up2.z;
		result.x = (ker[0][0] + ker[0][1] + ker[0][2])*current.w + ker[0][3]*up1.w + ker[0][4]*up2.w;		 
	}
	else if(y_index == 1){ // Our voxel has one neighbor below it
		up1 = vec_st[y_up_1][x_up_1];
		up2 = vec_st[y_up_2][x_up_2];
		down1 = vec_st[y_down_1][x_down_1];
		result.x = (ker[0][0] + ker[0][1])*down1.x + ker[0][2]*current.x + ker[0][3]*up1.x + ker[0][4]*up2.x;
		result.y = (ker[0][0] + ker[0][1])*down1.y + ker[0][2]*current.y + ker[0][3]*up1.y + ker[0][4]*up2.y;
		result.z = (ker[0][0] + ker[0][1])*down1.z + ker[0][2]*current.z + ker[0][3]*up1.z + ker[0][4]*up2.z;
		result.w = (ker[0][0] + ker[0][1])*down1.w + ker[0][2]*current.w + ker[0][3]*up1.w + ker[0][4]*up2.w;
	} 
	else if(y_index == dim.y-1){ // Our voxel has no neighbors above it
		down1 = vec_st[y_down_1][x_down_1];
		down2 = vec_st[y_down_2][x_down_2];
		result.x = ker[0][0]*down2.x + ker[0][1]*down1.x + ker[0][2]*current.x + (ker[0][3] + ker[0][4])*current.x;
		result.y = ker[0][0]*down2.y + ker[0][1]*down1.y + ker[0][2]*current.y + (ker[0][3] + ker[0][4])*current.y;
		result.z = ker[0][0]*down2.z + ker[0][1]*down1.z + ker[0][2]*current.z + (ker[0][3] + ker[0][4])*current.z;
		result.w = ker[0][0]*down2.w + ker[0][1]*down1.w + ker[0][2]*current.w + (ker[0][3] + ker[0][4])*current.w;
	}
	else if(y_index == dim.y-2){ // Our voxel has one neighbor above it
		up1 = vec_st[y_up_1][x_up_1];
		down1 = vec_st[y_down_1][x_down_1];
		down2 = vec_st[y_down_2][x_down_2];
		result.x = ker[0][0]*down2.x + ker[0][1]*down1.x + ker[0][2]*current.x + (ker[0][3] + ker[0][4])*up1.x;
		result.y = ker[0][0]*down2.y + ker[0][1]*down1.y + ker[0][2]*current.y + (ker[0][3] + ker[0][4])*up1.y;
		result.z = ker[0][0]*down2.z + ker[0][1]*down1.z + ker[0][2]*current.z + (ker[0][3] + ker[0][4])*up1.z;
		result.w = ker[0][0]*down2.w + ker[0][1]*down1.w + ker[0][2]*current.w + (ker[0][3] + ker[0][4])*up1.w;
	}
	else{ // Our voxel has two neighbors above and two neighbors below it
		up1 = vec_st[y_up_1][x_up_1];
		up2 = vec_st[y_up_2][x_up_2];
		down1 = vec_st[y_down_1][x_down_1];
		down2 = vec_st[y_down_2][x_down_2];
		result.x = ker[0][0]*down2.x + ker[0][1]*down1.x + ker[0][2]*current.x + ker[0][3]*up1.x + ker[0][4]*up2.x;
		result.y = ker[0][0]*down2.y + ker[0][1]*down1.y + ker[0][2]*current.y + ker[0][3]*up1.y + ker[0][4]*up2.y;
		result.z = ker[0][0]*down2.z + ker[0][1]*down1.z + ker[0][2]*current.z + ker[0][3]*up1.z + ker[0][4]*up2.z;
		result.w = ker[0][0]*down2.w + ker[0][1]*down1.w + ker[0][2]*current.w + ker[0][3]*up1.w + ker[0][4]*up2.w;
	}
}
#endif

// Kernel smooths the vector field in the z direction
kernel void k_average_z(float4 vec_st[][], 
			float3 dim, 
			float size, 
			out float4 result<>)
{
    float2 temp = indexof(result); // Get X, Y index of our stream element in texture memory
    float my_index = (size*temp.y + temp.x)*4; // Get the index of corresponding voxel in the 1D array
	
    if(my_index > dim.x*dim.y*dim.z){
	result = 0.0;
    }
    else{
	// Convert the 1D index into the corresponding x, y, and z position of voxel in the volume
	float z_index = floor(my_index/(dim.x*dim.y)); // Calculate the z index of the voxel
	float y_index = floor((my_index - z_index*(dim.x*dim.y))/dim.x); // Calculate the y index of the voxel
	float x_index = my_index - z_index*dim.x*dim.y - y_index*dim.x; // Calculate the x index of the voxel
	
	float4 current = vec_st[temp.y][temp.x]; // Index of our voxel in 2D texture
	float4 left; // Inside neighbor
	float4 right; // Outside neighbor
	
	float right_index = (my_index + dim.x*dim.y)/4; // Index of neighbor above our voxel in the 1D stream
	float y_right = floor(right_index/size); // Get corresponding x and y location in the texture memory
	float x_right = right_index - y_right*size;
	
	float left_index = (my_index - dim.x*dim.y)/4; // Index of neighbor below our voxel in the 1D stream
	float y_left = floor(left_index/size); // Get corresponding x and y location in the texture memory
	float x_left = left_index - y_left*size;
	
	float3 ker = float3(0.2740686238, 0.4518627524, 0.2740686238); // 3 element gaussian kernel
	
	if(z_index == 0){ // Our voxel has no left neighbor along the z direction
	    right = vec_st[y_right][x_right];
	    //result.x = (ker.x + ker.y)*current.x + ker.z*right.x;
	    //result.y = (ker.x + ker.y)*current.y + ker.z*right.y;
	    //result.z = (ker.x + ker.y)*current.z + ker.z*right.z;
	    //result.w = (ker.x + ker.y)*current.w + ker.z*right.w;
	    result.x = (ker.y)*current.x + ker.z*right.x;
	    result.y = (ker.y)*current.y + ker.z*right.y;
	    result.z = (ker.y)*current.z + ker.z*right.z;
	    result.w = (ker.y)*current.w + ker.z*right.w;
	}
	else if(z_index == dim.z-1){// Our voxel has no right neighbor along the z direction
	    left = vec_st[y_left][x_left];
	    //result.x = ker.x*left.x + (ker.y + ker.z)*current.x;
	    //result.y = ker.x*left.y + (ker.y + ker.z)*current.y;
	    //result.z = ker.x*left.z + (ker.y + ker.z)*current.z;
	    //result.w = ker.x*left.w + (ker.y + ker.z)*current.w;
	    result.x = ker.x*left.x + (ker.y)*current.x;
	    result.y = ker.x*left.y + (ker.y)*current.y;
	    result.z = ker.x*left.z + (ker.y)*current.z;
	    result.w = ker.x*left.w + (ker.y)*current.w;
	}
	else{ // Our voxel has both left and right neighbors
	    left = vec_st[y_left][x_left];
	    right = vec_st[y_right][x_right];
	    result.x = ker.x*left.x + ker.y*current.x + ker.z*right.x;
	    result.y = ker.x*left.y + ker.y*current.y + ker.z*right.y;
	    result.z = ker.x*left.z + ker.y*current.z + ker.z*right.z;
	    result.w = ker.x*left.w + ker.y*current.w + ker.z*right.w;
	}
    }	
}

/* Kernel smooths the vector field in the x direction. Assumes dim.x is divisible by 4. */
kernel void k_conv_x(float4 img[][],				// Input:  input image
			float ker[],				// Input:  convolution kernel
			float ker_size,				// Input:  convolution kernel size
			float3 dim,				// Input:  volume dimensions
			float size,				// Input:  texture memory dimensions
			out float4 result<>)			// Output: convolved image
{
    float2 temp = indexof(result);		// Get X, Y index of our stream element in texture memory
    float my_index = (size*temp.y + temp.x)*4;	// Get the index of corresponding voxel in the 1D array
    float pidx;
    float kidx;
    float acc;
    float ker_size_2 = floor ((ker_size-1) / 2);	/* Assume ker_size is odd */

    if (my_index > dim.x*dim.y*dim.z) {
	result = 0.0;
    }
    else {
	// Convert the 1D index into the corresponding x, y, and z position of voxel in the volume
	float z_idx = floor(my_index/(dim.x*dim.y));			    // Calculate the z index of the voxel
	float y_idx = floor((my_index - z_idx*(dim.x*dim.y))/dim.x);        // Calculate the y index of the voxel
	float x_idx = my_index - z_idx*dim.x*dim.y - y_idx*dim.x;	    // Calculate the x index of the voxel
	
        float4 acc = 0.0;

	// Iterate through convolution kernel
	for (kidx = 0; kidx < ker_size; kidx=kidx+1.0) {
	    float kx_idx, kx_idx1, kx_idx2;
	    float k_lin_idx1, k_lin_idx2;
	    float k_tex_x1, k_tex_y1, k_tex_x2, k_tex_y2;
	    float4 val1;
	    float4 val2;
	    float4 img_val;
	    float kx_case;
	    
	    /* x index of base voxel overlapping this kidx. */
	    kx_idx = x_idx + kidx - ker_size_2;

	    /* There may be a one or two voxel overlap.  Find indices for both. */
	    kx_idx1 = 4 * floor(kx_idx / 4);
	    kx_idx2 = kx_idx1 + 4;
	    k_lin_idx1 = floor((z_idx * dim.x * dim.y + y_idx * dim.x + kx_idx1) / 4);
	    k_lin_idx2 = k_lin_idx1 + 1;
	    k_tex_y1 = floor(k_lin_idx1 / size);
	    k_tex_y2 = floor(k_lin_idx2 / size);
	    k_tex_x1 = k_lin_idx1 - k_tex_y1 * size;
	    k_tex_x2 = k_lin_idx2 - k_tex_y2 * size;
	    
	    /* Grab image float4's for both voxels */
	    /* This is zero padded */
	    if (kx_idx1 < 0) {
		val1 = 0.0;
	    } else if (kx_idx1 > dim.x - 1) {
		val1 = 0.0;
	    } else {
		val1 = img[k_tex_y1][k_tex_x1];
	    }
	    if (kx_idx2 < 0) {
		val2 = 0.0;
	    } else if (kx_idx2 > dim.x - 1) {
		val2 = 0.0;
	    } else {
		val2 = img[k_tex_y2][k_tex_x2];
	    }

	    /* Figure out which of four cases we are in.
	       case 0:  xyzw|
	       case 1:  yzw|x
	       case 2:  zw|xy
	       case 3:  w|xyz
	    */
	    kx_case = kx_idx - 4*floor(kx_idx / 4);
	    if (kx_case == 0) {
		/* GCS: I wonder why the following doesn't work correctly?
		    img_val = val1;
		   Instead, I have to use 4 assignment statements. */
		img_val.x = val1.x;
		img_val.y = val1.y;
		img_val.z = val1.z;
		img_val.w = val1.w;
	    }
	    else if (kx_case == 1) {
		img_val.x = val1.y;
		img_val.y = val1.z;
		img_val.z = val1.w;
		img_val.w = val2.x;
	    }
	    else if (kx_case == 2) {
		img_val.x = val1.z;
		img_val.y = val1.w;
		img_val.z = val2.x;
		img_val.w = val2.y;
	    }
	    else if (kx_case == 3) {
		img_val.x = val1.w;
		img_val.y = val2.x;
		img_val.z = val2.y;
		img_val.w = val2.z;
	    }

	    acc = acc + ker[kidx] * img_val;
	}
	result = acc;
    }
}

/* Kernel smooths the vector field in the y direction. Assumes dim.x is divisible by 4. */
kernel void k_conv_y(float4 img[][],				// Input:  input image
			float ker[],				// Input:  convolution kernel
			float ker_size,				// Input:  convolution kernel size
			float3 dim,				// Input:  volume dimensions
			float size,				// Input:  texture memory dimensions
			out float4 result<>)			// Output: convolved image
{
    float2 temp = indexof(result);		// Get X, Y index of our stream element in texture memory
    float my_index = (size*temp.y + temp.x)*4;	// Get the index of corresponding voxel in the 1D array
    float pidx;
    float kidx;
    float acc;
    float ker_size_2 = floor ((ker_size-1) / 2);	/* Assume ker_size is odd */

    if (my_index > dim.x*dim.y*dim.z) {
	result = 0.0;
    }
    else {
	// Convert the 1D index into the corresponding x, y, and z position of voxel in the volume
	float z_idx = floor(my_index/(dim.x*dim.y));			    // Calculate the z index of the voxel
	float y_idx = floor((my_index - z_idx*(dim.x*dim.y))/dim.x);        // Calculate the y index of the voxel
	float x_idx = my_index - z_idx*dim.x*dim.y - y_idx*dim.x;	    // Calculate the x index of the voxel
	
        float4 acc = 0.0;

	// Iterate through convolution kernel
	for (kidx = 0; kidx < ker_size; kidx=kidx+1.0) {
	    float ky_idx = y_idx + kidx - ker_size_2;			    /* z index of voxel overlapping this kidx */
	    float k_lin_idx;
	    float k_tex_y;
	    float k_tex_x;
	    float4 val;
	    
	    /* This is for zero-padded */
	    k_lin_idx = (z_idx * dim.x * dim.y + ky_idx * dim.x + x_idx) / 4;
	    k_tex_y = floor(k_lin_idx / size);
	    k_tex_x = k_lin_idx - k_tex_y * size;

	    if (ky_idx < 0) {
		val = 0.0;
	    } else if (ky_idx > dim.y - 1) {
		val = 0.0;
	    } else {
		val = img[k_tex_y][k_tex_x];
	    }

	    acc = acc + ker[kidx] * val;
	}
	result = acc;
    }
}

/* Kernel smooths the vector field in the z direction. Assumes dim.x is divisible by 4. */
kernel void k_conv_z(float4 img[][],				// Input:  input image
			float ker[],				// Input:  convolution kernel
			float ker_size,				// Input:  convolution kernel size
			float3 dim,				// Input:  volume dimensions
			float size,				// Input:  texture memory dimensions
			out float4 result<>)			// Output: convolved image
{
    float2 temp = indexof(result);		// Get X, Y index of our stream element in texture memory
    float my_index = (size*temp.y + temp.x)*4;	// Get the index of corresponding voxel in the 1D array
    float pidx;
    float kidx;
    float acc;
    float ker_size_2 = floor ((ker_size-1) / 2);	/* Assume ker_size is odd */

    if (my_index > dim.x*dim.y*dim.z) {
	result = 0.0;
    }
    else {
	// Convert the 1D index into the corresponding x, y, and z position of voxel in the volume
	float z_idx = floor(my_index/(dim.x*dim.y));			    // Calculate the z index of the voxel
	float y_idx = floor((my_index - z_idx*(dim.x*dim.y))/dim.x);        // Calculate the y index of the voxel
	float x_idx = my_index - z_idx*dim.x*dim.y - y_idx*dim.x;	    // Calculate the x index of the voxel
	
        float4 acc = 0.0;

	// Iterate through convolution kernel
	for (kidx = 0; kidx < ker_size; kidx=kidx+1.0) {
	    float kz_idx = z_idx + kidx - ker_size_2;			    /* z index of voxel overlapping this kidx */
	    float k_lin_idx;
	    float k_tex_y;
	    float k_tex_x;
	    float4 val;
	    
	    /* This is for boundary-padded */
	    /*
	    if (kz_idx < 0) {
		kz_idx = 0.0;
	    } else if (kz_idx > dim.z - 1) {
		kz_idx = dim.z - 1;
	    }

	    k_lin_idx = (kz_idx * dim.x * dim.y + y_idx * dim.x + x_idx) / 4;
	    k_tex_y = floor(k_lin_idx / size);
	    k_tex_x = k_lin_idx - k_tex_y * size;

	    acc = acc + ker[kidx] * img[k_tex_y][k_tex_x];
	    */
	    
	    /* This is for zero-padded */
	    k_lin_idx = (kz_idx * dim.x * dim.y + y_idx * dim.x + x_idx) / 4;
	    k_tex_y = floor(k_lin_idx / size);
	    k_tex_x = k_lin_idx - k_tex_y * size;

	    if (kz_idx < 0) {
		val = 0.0;
	    } else if (kz_idx > dim.z - 1) {
		val = 0.0;
	    } else {
		val = img[k_tex_y][k_tex_x];
	    }

	    acc = acc + ker[kidx] * val;
	}
	result = acc;
    }
}

kernel void test_ker(float in_d[][],
					 out float result<>)
{
	float2 temp = indexof(result); 
	result = in_d[temp.y][temp.x];
}
