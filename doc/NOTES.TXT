***** Organization of learning code *****

Use cases:

image: can be 2d (slice) or 3d (vol)
pos: can be 1d (slice loc), 2d (in-plane), or 3d (position)
binary (in/out, male/female)
tri-state (above, near, below)
continuous tri-state (above (+1), near (-1 to +1), below (-1))
conditional position (inside (with position), outside (without position))

- T-spine

slice -> slice loc
slice -> in-plane

- Lung apex

slice -> continuous tri-state

- T-spine

slice + continuous tri-state -> slice loc

Finding training data:

T-spine: Choose only slice or vol centered at fiducial
T-spine: Interpolate fiducials, use all slices
Lung apex: Choose only slice at apex
Lung apex: Choose all slices, compute distance to apex
Lung volume: Choose all slices intersecting mask

Transition plan:

Use hard-coded training routines for different use cases

plastimatch autolabel-train \
    --task t-spine-v1 \
    --input dir \
    --output net


***** Organization for irregular volume (transition plan) *****

(1) Use native, not ITK

(2) Only support volumes with irregular slice spacing.  No support 
for things like changing pixel size or direction cosines

(3) Add irregular volume as a member of Volume

class Volume {
      /* Regular volume stuff */
      int npix;
      void *data;

      /* Irregular volume stuff */
      float *irr_spacing;
      void **irr_data;
};

***** Writing a Slicer4 loadable module *****

(1) Use the wizard to make a template

export SD=$HOME/build/slicer-4/Slicer4
python ${SD}/Scripts/ModuleWizard.py \
       --template ${SD}/QTModules/ModuleTemplate \
       --target MY_MODULE_NAME \
       MY_MODULE_NAME

(2) Modify CMakeLists.txt

find_package (Slicer QUIET)
if (SLICER_FOUND)
  include ("${Slicer_USE_FILE}")
  if (SLICER_IS_SLICER4)
    add_subdirectory (QTModules/MY_MODULE_NAME)
  endif ()
endif ()

(3) Copy over TestingMacros.h

cp ${SD}/TestingMacros.h MY_MODULE_NAME

At this point you can compile, and it runs.  But it builds directly 
into the slicer directory.  This can be (partly) defeated using 
the following strategy, but it is a moot point because you can't yet 
set the module search path.  Here is the strategy:

(4) Defeat Slicer overwriting CMAKE_* variables

  if (Slicer_USE_FILE)
    set (OLD_CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
    set (OLD_CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_LIBRARY_OUTPUT_DIRECTORY})
    set (OLD_CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})

    include ("${Slicer_USE_FILE}")

    set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${OLD_CMAKE_RUNTIME_OUTPUT_DIRECTORY})
    set (CMAKE_LIBRARY_OUTPUT_DIRECTORY ${OLD_CMAKE_LIBRARY_OUTPUT_DIRECTORY})
    set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${OLD_CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
  endif ()

(5) Edit CMakeLists.txt files generated by the python script.  
There are two files to edit: MY_MODULE_NAME/CMakeLists.txt, 
and MY_MODULE_NAME/Logic/CMakeLists.txt.

(5a) For MY_MODULE_NAME/CMakeLists.txt, do the following:

set (lib_name qSlicer${qt_module_name}Module)
set_target_properties (${lib_name} PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${Slicer_INSTALL_QTLOADABLEMODULES_BIN_DIR}"
  LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${Slicer_INSTALL_QTLOADABLEMODULES_LIB_DIR}"
  ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${Slicer_INSTALL_QTLOADABLEMODULES_LIB_DIR}"
  )

(5b) For MY_MODULE_NAME/Logic/CMakeLists.txt, do the following:

SlicerMacroBuildModuleLogic(
  NAME ${module_logic_name}
  DISABLE_WRAP_PYTHON
  EXPORT_DIRECTIVE ${module_logic_export_directive}
  INCLUDE_DIRECTORIES ${module_logic_include_directories}
  SRCS ${module_logic_SRCS}
  TARGET_LIBRARIES ${module_logic_target_libraries}
  )

set_target_properties (${module_logic_name} PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${Slicer_INSTALL_QTLOADABLEMODULES_BIN_DIR}"
  LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${Slicer_INSTALL_QTLOADABLEMODULES_LIB_DIR}"
  ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${Slicer_INSTALL_QTLOADABLEMODULES_LIB_DIR}"
  )

***** Proton dose ideas *****

Stage 1(a): Compute pencil beam in standard grid
(z direction is pdd in water)
(x-y direction is scatter in water, or just 1-d with distance)

Stage 1(b): Compute RPL in interpolated coordinate system
(z axis is beam axis)
(x-y perpendicular to beam, arbitrary v-up vector)

Stage 2: For each voxel
  a) Look up primary in RPL grid
  b) Convolve to find scatter within x-y axis of primary grid (ignoring tilt)

***** File browser design *****

http://www.xvsxp.com/files/file_browsing.php
http://rixstep.com/4/0/xfile/ss.shtml
http://www.ragesw.com/products/explorer/screenshots/1/

***** Writing to stdout in Qt *****

    QTextStream(stdout) << QString("foo") << "\n";

***** dgate quite ref (for wormwood) *****

cd ~/build/conquest-1.4.15
./dgate &

***** dcmtk quick ref *****

Run the dicom server like this:

  $ dcmqrscp

It will read a file "dcmqrscp.cfg" in the current directory, which is used 
to set user/group, port, AET, storage directory.  NOTE: Be very careful 
about extra spaces in the list of remote AETs.  Here the file I used 
for these tests:

--- begin here ---
NetworkType     = "tcp"
NetworkTCPPort  = 9885
MaxPDUSize      = 16384
MaxAssociations = 16
Display         = "no"
UserName        = "gsharp"
GroupName       = "gsharp"
HostTable BEGIN
entry1           = (MOVESCU, localhost, 19530)
entry2           = (STORESCP, localhost, 19335)
HostTable END
VendorTable BEGIN
VendorTable END
AETable BEGIN
READWRITE     /home/gsharp/projects/dicom-test/junk RW (10, 1024mb)  ANY
AETable END
--- end here ---

Send files to database like this:

  $ storescu -aec READWRITE localhost 9885 *.dcm

Query the database like this:

  $ findscu -P -k 0010,0010 -k 0008,0052=PATIENT -aec READWRITE localhost 9885

Retrieve from the database like this:

  $ movescu -v --patient -aet MOVESCU -aem MOVESCU -aec READWRITE --port 19530 -k 0008,0052=PATIENT -k 0010,0020=PL811332912032439 localhost 9885

Or like this:

  $ storescp 19335 &
  $ movescu -v --patient -aet MOVESCU -aem STORESCP -aec READWRITE -k 0008,0052=PATIENT -k 0010,0020=PL811332912032439 localhost 9885


***** Proposed engineering changes: Aug 1, 2009 *****

1) Reduce number of executables

   Old:
     plastimatch [options]
     dicom_to_mha [options]
     warp_mha [options]
   New:
     plastimatch register [options]
     plastimatch convert [options]
     plastimatch warp [options]

   "Simple" executables such as bspline.exe, drr_c.exe etc. will not 
   be merged.

2) Add threading options to plastimatch

   Old:
     implementation=gpuit_cpu
   New:
     implementation=plastimatch
     threading=openmp
     max_threads=2

3) Remove gpuit sub-library, merge into plastimatch1.lib

4) Move source code to src/ subdirectory

***** Consistency of indices *****

By convention:

   k, z = slowest moving index (usually IS)
   j, y = middle moving index (usually AP)
   i, x = fastest moving index (usually RL)

Arrays which hold things like the dimensions are indexed as follows:

   dim[0] = dimensions of fastest moving index
   dim[1] = dimensions of middle moving index
   dim[2] = dimensions of slowest moving index

Loops should be nested from slowest index to fastest index.  
Therefore, the correct nesting is:

    for (k = 0; k < fixed->dim[2]; k++) {
	for (j = 0; j < fixed->dim[1]; j++) {
	    for (i = 0; i < fixed->dim[0]; i++) { ... } } }

Embedded indices, such as (x,y,z) coordinates of the vector 
field at a voxel, should be in the order of x, then y, then z.

When you pass indices into a function it should be 
in order x, then y, then z.  For example:

    int volume_index (int* dims, int i, int j, int k);

***** How to compile libf2c *****

Edit libf2c/makefile.vc, and change:
  CFLAGS = -DUSE_CLOCK -DMSDOS -DNO_ONEXIT -Ot1

To:
  CFLAGS = -DUSE_CLOCK -DMSDOS -DNO_ONEXIT -Ot1 -MD

Edit libf2c/fio.h, and comment out:
  extern int isatty(int);

***** How to compile the .br into .cpp *****

The default compile is simply: 
   brcc -o outfile.cpp infile.br

The FDK code doesn't work for PS20 & ARB targets.

We can use -p flag to set the platform.
   brcc -o outfile.cpp

***** How to compile brook on cygwin/g++ *****

1) The config/DetectOS thing always gets Windows_NT because 
the $OS environment variable is standard in Windows.

2) Need to create a new *.mk file  (To be done)

3) It seems to build OK, but doesn't completely solve the 
problem.  fxc still requires windows style paths, maybe cgc does too.

***** Threads vs OpenMP *****

http://www.intel.com/cd/ids/developer/asmo-na/eng/technologies/threading/hyperthreading/53797.htm

https://computing.llnl.gov/tutorials/openMP/

On GCC:
  gcc -fopenmp openmp_test.c

Visual studio 2005 supports OpenMP 2.0
  cl /openmp

Express version does not support OpenMP (except as described below)
  http://blog.codekills.net/archives/25-OpenMP-and-Visual-C++-the-free-way-sorta.html
MinGW gcc OpenMP is still not fully supported
  http://www.nabble.com/OpenMP-and-shared-libgcc-td17516165.html

***** What is the deal with ITK's oriented images? *****

http://www.itk.org/pipermail/insight-users/2008-August/027102.html

Now, ITK 3.10.2 has two flags (earlier version are similar).
The use of these flags are not well described.

ITK_USE_ORIENTED_IMAGE_DIRECTION
ITK_IMAGE_BEHAVES_AS_ORIENTED_IMAGE

***** Logging *****

For "C" logging, I found 2 projects:

- log4c (LGPL license)
- pantheios (BSD license)

***** Timing *****

Options:
1) clock()
2) time()
3) gettimeofday()
4) QueryPerformanceCounter  // windows only
5) OpenMP timer
6a) clock_gettime(CLOCK_MONOTONIC)
6b) clock_gettime(CLOCK_REALTIME)
6c) clock_gettime(CLOCK_HIGHRES) // solaris only?

http://en.wikipedia.org/wiki/Real-time_clock
http://en.wikipedia.org/wiki/High_Precision_Event_Timer

http://cboard.cprogramming.com/c-programming/106025-clock-vs-gettimeofday.html
http://fixunix.com/linux/6645-negative-response-time-gettimeofday.html
http://code.google.com/p/high-resolution-timer/source/browse/trunk/highrestimer/c%2B%2B_library/wraper_and_library/timer_library.c

***** SVN eol-goop *****

Put the following in your ~/.subversion/config

CMakeLists.txt = svn:eol-style=native;svn:mime-type=text/plain
Makefile = svn:eol-style=native;svn:mime-type=text/plain
README* = svn:mime-type=text/plain;svn:eol-style=native
readme* = svn:mime-type=text/plain;svn:eol-style=native

*.tga = svn:mime-type=image/tga
*.bat = svn:mime-type=text/plain;svn:eol-style=CRLF
*.br = svn:eol-style=native;svn:mime-type=text/plain
*.c = svn:eol-style=native;svn:mime-type=text/plain
*.cmake = svn:mime-type=text/plain;svn:eol-style=native
*.cmd = svn:mime-type=text/plain;svn:eol-style=CRLF
*.cpp = svn:eol-style=native;svn:mime-type=text/plain
*.cu = svn:eol-style=native;svn:mime-type=text/plain
*.cxx = svn:eol-style=native;svn:mime-type=text/plain
*.dsp = svn:eol-style=CRLF;svn:mime-type=text/plain
*.dsw = svn:eol-style=CRLF;svn:mime-type=text/plain
*.f = svn:eol-style=native;svn:mime-type=text/plain
*.h = svn:eol-style=native;svn:mime-type=text/plain
*.jpg = svn:mime-type=image/jpeg
*.m = svn:eol-style=native;svn:mime-type=text/plain
*.pl = svn:eol-style=native;svn:mime-type=text/plain;svn:executable
*.png = svn:mime-type=image/png
*.pm = svn:eol-style=native;svn:mime-type=text/plain
*.sh = svn:mime-type=text/plain;svn:eol-style=LF;svn:executable
*.txt = svn:mime-type=text/plain;svn:eol-style=native
*.xml = svn:mime-type=text/xml;svn:eol-style=native
